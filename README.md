# RTL-DESIGN-USING-VERILOG-WITH-SKY130-TECHNOLOGY
## Table of Contents
```
 1. Day1 - Introduction to Verilog RTL design and synthesis
  1.1. SKY130RTL D1SK1 - Introduction to open-source simulator iverilog
   1.1.1 SKY130RTL D1SK1 L1 Introduction iverilog design and test bench
  1.2  SKY130RTL D1SK2- Labs using iverilog and gtkwave
    1.2.1 SKY130RTL D1SK2 L1 Lab1 introduction to lab
    1.2.2 SKY130RTL D1SK2 L2 Lab2 introduction to iverilog gtkwave part1
    1.2.3 SKY130RTL D1SK2 L3 Lab2 introduction to iverilog gtkwave part2
  1.3 SKY130RTL D1SK3 Introduction to Yosys and Logic synthesis
    1.3.1 SKY130RTL D1SK3 L1 Introduction to yosys
    1.3.2 SKY130RTL D1SK3 L2 Introduction to logic synthesis part1
    1.3.3 SKY130RTL D1SK3 L3 Introduction to logic synthesis part2
 1.4 SKY130RTL D1SK4 Labs using Yosys and SKY130PDK's
    1.4.1 SKY130RTL D1SK4 L1 Lab3 yosys 1 good mux Part1
    1.4.1 SKY130RTL D1SK4 L2 Lab3 yosys 1 good mux Part2
    1.4.1 SKY130RTL D1SK4 L3 Lab3 yosys 1 good mux Part3
 2. Day 2-Timing libs, hierarchial vs flat synthesis and efficient flop coding styles
  2.1 SKY130RTL D2SK1 -Introduction to timing.libs
    2.1.1 SKY130RTL D2SK1 L1 Lab4 Introduction to dot lib part1
    2.1.2 SKY130RTL D2SK1 L2 Lab4 Introduction to dot lib part2
    2.1.3 SKY130RTL D2SK1 L3 Lab4 Introduction to dot lib part3
  2.2 SKY130RTL D2SK2 - Hierarchial vs Flat Synthesis
    2.2.1 SKY130RTL D2SK2 L1 Lab5 hierarchial vs flat synthesis part1
    2.2.2 SKY130RTL D2SK2 L2 Lab5 hierarchial vs flat synthesis part2
  2.3 SKY130RTL D2SK3 - Various Flop Coding Styles and optimization
    2.3.1 SKY130RTL D2SK3 L1 Why Flops and Flop coding styles part1
    2.3.2 SKY130RTL D2SK3 L2 Why Flops and Flop coding styles part2
    2.3.3 SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1
    2.3.4 SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2
    2.3.5 SKY130RTL D2SK3 L5 Intresting optimizations part1
    2.3.6 SKY130RTL D2SK3 L6 Intresting optimizations part2
```
## 1. Day1 - Introduction to Verilog RTL design and synthesis
### 1.1. SKY130RTL D1SK1 - Introduction to open-source simulator iverilog
Simulator is tool used for simulating the design. iverilog is a open source simulator. Simulating Register transfer level (RTL) design checks adherence of RTL design to specifications. 
#### 1.1.1. SKY130RTL D1SK1 L1 Introduction iverilog design and test bench
Design is a verilog code intended for particular functionality to meet with the required specifications.TestBench is the setup to apply stimulus to the design to check its functionality. Fig 1 shows working of testbench.
![1](https://user-images.githubusercontent.com/62790565/183249511-3da7501f-e4a4-4fa0-90a3-cf6888604666.jpeg)
Fig 1
Simulator looks for the changes on the input signals, upon changes to the input the output is evaluated. Fig 2 shows iverilog based simulation flow, Applying Design and testbench to iverilog simulator generates value Change Dump (vcd) file indicates that any changes in the input are dumped to output. gtkwave tool is used to view the input and output waveforms.
![2](https://user-images.githubusercontent.com/62790565/183249896-56e0d3bc-885d-40b6-8c9a-a75ccb72ca6a.jpeg)
Fig 2
###  1.2  SKY130RTL D1SK2- Labs using iverilog and gtkwave
Fig 3 shows terminal window creating a directory VLSI and git clone sky130RTLDesignAndSynthesisWorkshop directory from https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git and walking through files in sky130RTLDesignAndSynthesisWorkshop directory. lib folder consists of all sky130 library cells and verilog_model consits of verilog code for all the standard cells.``
Fig 3
In this session, I've performed simulation of multiplexer. I've added both the RTL design code and test bench code in iverilog to generate vcd file which I used in gtkwave generator to get the output waveformes after simulation. The output was generated by taking the inputs from the testbench code.
Here is design code multiplexer
```
module good_mux (input i0 , input i1 , input sel , output reg y); 
	always @ (*)
	begin
		if(sel)
		y <= i1;
		else 
		y <= i0;
	end
endmodule**
```
Testbench code of multiplexer
```
`timescale 1ns / 1ps
module tb_good_mux;
// Inputs
reg i0,i1,sel;
// Outputs
wire y;
  		// Instantiate the Unit Under Test (UUT), name based instantiation
	good_mux uut (.sel(sel),.i0(i0),.i1(i1),.y(y));
	//good_mux uut (sel,i0,i1,y);  //order based instantiation
initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
end
always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule*
```
The following commands on terminal to simulate multiplexer design code
```
$ iverilog good_mux.v tb_good_mux.v
$ ./a.out
$ gtkwave tb_good_mux.vcd
```
Fig 4 is  a view of output of multiplexer on gtkwave
![Screenshot from 2022-08-06 19-19-58](https://user-images.githubusercontent.com/62790565/183253261-e6831deb-7bf6-4d22-a8d1-f420e5ca653c.png)
Fig 4
### 1.3 SKY130RTL D1SK3 Introduction to Yosys and Logic synthesis
#### 1.3.1 SKY130RTL D1SK3 L1 Introduction to yosys
Yosys is a synthesizer, a tool used for converting the RTL to netlist.Fig 5 shows the flow of yosys,applying design and .lib files to yosys we get netlist as output.read_verilog command is used to read the design, read_liberty command to read the .lib file and write_verilog command to write out the netlist file.Netlist is representation of the design in form of cells present in .lib.
![5](https://user-images.githubusercontent.com/62790565/183275983-e5d109b6-a27e-4dc2-ab8b-1d9cacadafb6.jpeg)
Fig 5
Output of simulating by applying netlist and testbench to iverilog and viewing generated vcd file on gtkwave toolshould be same as output of simulating by applying design and testbench to iverilog and viewing generated vcd file on gtkwave provided testbench applied in both the cases should is same, then the sysnthesis is said to be verified.
![6](https://user-images.githubusercontent.com/62790565/183276366-111784a5-b222-4721-90f6-b44a21aa0112.jpeg)
Fig 6
#### 1.3.2 SKY130RTL D1SK3 L2 Introduction to logic synthesis part1
RTL design is a behavioral representation of the required specification .Synthesis is RTL to Gate level translation. the design is converted into gates and the connections are made between the gates. This gives out as a file called netlist.Fig 7 gives the illustration of synthesis
![7](https://user-images.githubusercontent.com/62790565/183277889-190764f8-0f55-462c-8226-6d74e1f8a031.jpeg)

Fig 7
.lib is a collection of logical modules.It includes basic logic gates like And, Or, Not, etc. Same gate has different flavours such has slow, medium, fast.

![8](https://user-images.githubusercontent.com/62790565/183277894-226874e3-d83e-43c2-9e27-39dff657d03b.jpeg)

Fig 8
Consider the above digital circuit, the minimum clock period is given by the equation :
```
Tclk > Tcq-a + Tcombi +Tsetup-b
```
Combinational delay in logic path determines the maximum speed of operation of digital logic circuit.So we need fast cells to make Tcombi small increases the speed of operation.The following equation gives the maximum hold time
```
Thold_b < Tcq_a +Tcombi
```
To ensure that there are n "HOLD" issues at DFF_B shown in Fig 8,  we need cells that work slowly. Hence we need cells that works fast to meet the required performance and we need cells that work slow to meet HOLD. This collection of different flavours of cells forms the .lib . Load in the Digital Logic circuit is capacitance. Faster the charging/ discharging of capacitance lesser the cell delay. To charge or discharge the capacitance fast, we need transistors capable of sourcing more current. Wide transistors offfers low delay but requires mre area and power. Narrow transistors requires less area and power but offers more delay. Hence faster cells comes with a penality of area and power.
### 1.4 SKY130RTL D1SK4 Labs using Yosys and SKY130PDK's
#### 1.4.1 SKY130RTL D1SK4 L1 Lab3 yosys 1 good mux Part1
Moving into VLSI to sky130RTLDesignAndSynthesisWorkshop to verilog_files and then invoking yosys
```
$ cd VLSI
$ cd sky130RTLDesignAndSynthesisWorkshop
$ cd verilog_files
$ yosys
yosys >
```
Reading library files and design of multiplexer and synthesizing it and displaying gates
```
> read_liberty -lib /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
> read_verilog good_mux.v
> synth -top good_mux
> abc -liberty /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
> show
```

![Screenshot from 2022-08-07 12-13-20](https://user-images.githubusercontent.com/62790565/183279565-365fd63f-2081-43d2-952d-8ef6bf9b1ce3.png)

Generating netlist and displaying it
```
> write_verilog -noattr good_mux_netlist.v
> !gvim good_mux_netlist.v
```
Fig9 shows the netlist

