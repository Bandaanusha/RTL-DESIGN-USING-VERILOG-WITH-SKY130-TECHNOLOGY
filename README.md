# RTL-DESIGN-USING-VERILOG-WITH-SKY130-TECHNOLOGY
## Table of Contents
```
 1. Day1 - Introduction to Verilog RTL design and synthesis
  1.1. SKY130RTL D1SK1 - Introduction to open-source simulator iverilog
   1.1.1 SKY130RTL D1SK1 L1 Introduction iverilog design and test bench
  1.2  SKY130RTL D1SK2- Labs using iverilog and gtkwave
    1.2.1 SKY130RTL D1SK2 L1 Lab1 introduction to lab
    1.2.2 SKY130RTL D1SK2 L2 Lab2 introduction to iverilog gtkwave part1
    1.2.3 SKY130RTL D1SK2 L3 Lab2 introduction to iverilog gtkwave part2
  1.3 SKY130RTL D1SK3 Introduction to Yosys and Logic synthesis
    1.3.1 SKY130RTL D1SK3 L1 Introduction to yosys
    1.3.2 SKY130RTL D1SK3 L2 Introduction to logic synthesis part1
    1.3.3 SKY130RTL D1SK3 L3 Introduction to logic synthesis part2
 1.4 SKY130RTL D1SK4 Labs using Yosys and SKY130PDK's
    1.4.1 SKY130RTL D1SK4 L1 Lab3 yosys 1 good mux Part1
    1.4.1 SKY130RTL D1SK4 L2 Lab3 yosys 1 good mux Part2
    1.4.1 SKY130RTL D1SK4 L3 Lab3 yosys 1 good mux Part3
 2. Day 2-Timing libs, hierarchial vs flat synthesis and efficient flop coding styles
  2.1 SKY130RTL D2SK1 -Introduction to timing.libs
    2.1.1 SKY130RTL D2SK1 L1 Lab4 Introduction to dot lib part1
    2.1.2 SKY130RTL D2SK1 L2 Lab4 Introduction to dot lib part2
    2.1.3 SKY130RTL D2SK1 L3 Lab4 Introduction to dot lib part3
  2.2 SKY130RTL D2SK2 - Hierarchial vs Flat Synthesis
    2.2.1 SKY130RTL D2SK2 L1 Lab5 hierarchial vs flat synthesis part1
    2.2.2 SKY130RTL D2SK2 L2 Lab5 hierarchial vs flat synthesis part2
  2.3 SKY130RTL D2SK3 - Various Flop Coding Styles and optimization
    2.3.1 SKY130RTL D2SK3 L1 Why Flops and Flop coding styles part1
    2.3.2 SKY130RTL D2SK3 L2 Why Flops and Flop coding styles part2
    2.3.3 SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1
    2.3.4 SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2
    2.3.5 SKY130RTL D2SK3 L5 Intresting optimizations part1
    2.3.6 SKY130RTL D2SK3 L6 Intresting optimizations part2
```
## 1. Day1 - Introduction to Verilog RTL design and synthesis
### 1.1. SKY130RTL D1SK1 - Introduction to open-source simulator iverilog
Simulator is tool used for simulating the design. iverilog is a open source simulator. Simulating Register transfer level (RTL) design checks adherence of RTL design to specifications. 
#### 1.1.1. SKY130RTL D1SK1 L1 Introduction iverilog design and test bench
Design is a verilog code intended for particular functionality to meet with the required specifications.TestBench is the setup to apply stimulus to the design to check its functionality. Fig 1 shows working of testbench.
![1](https://user-images.githubusercontent.com/62790565/183249511-3da7501f-e4a4-4fa0-90a3-cf6888604666.jpeg)
<br>Fig 1
<br>Simulator looks for the changes on the input signals, upon changes to the input the output is evaluated. Fig 2 shows iverilog based simulation flow, Applying Design and testbench to iverilog simulator generates value Change Dump (vcd) file indicates that any changes in the input are dumped to output. gtkwave tool is used to view the input and output waveforms.
![2](https://user-images.githubusercontent.com/62790565/183249896-56e0d3bc-885d-40b6-8c9a-a75ccb72ca6a.jpeg)
Fig 2
###  1.2  SKY130RTL D1SK2- Labs using iverilog and gtkwave
Fig 3 shows terminal window creating a directory VLSI and git clone sky130RTLDesignAndSynthesisWorkshop directory from https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git and walking through files in sky130RTLDesignAndSynthesisWorkshop directory. lib folder consists of all sky130 library cells and verilog_model consits of verilog code for all the standard cells.``
Fig 3
In this session, I've performed simulation of multiplexer. I've added both the RTL design code and test bench code in iverilog to generate vcd file which I used in gtkwave generator to get the output waveformes after simulation. The output was generated by taking the inputs from the testbench code.
Here is design code multiplexer
```
module good_mux (input i0 , input i1 , input sel , output reg y); 
	always @ (*)
	begin
		if(sel)
		y <= i1;
		else 
		y <= i0;
	end
endmodule**
```
Testbench code of multiplexer
```
`timescale 1ns / 1ps
module tb_good_mux;
// Inputs
reg i0,i1,sel;
// Outputs
wire y;
  		// Instantiate the Unit Under Test (UUT), name based instantiation
	good_mux uut (.sel(sel),.i0(i0),.i1(i1),.y(y));
	//good_mux uut (sel,i0,i1,y);  //order based instantiation
initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
end
always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule*
```
The following commands on terminal to simulate multiplexer design code
```
$ iverilog good_mux.v tb_good_mux.v
$ ./a.out
$ gtkwave tb_good_mux.vcd
```
Fig 4 is  a view of output of multiplexer on gtkwave
![Screenshot from 2022-08-06 19-19-58](https://user-images.githubusercontent.com/62790565/183253261-e6831deb-7bf6-4d22-a8d1-f420e5ca653c.png)
Fig 4
### 1.3 SKY130RTL D1SK3 Introduction to Yosys and Logic synthesis
#### 1.3.1 SKY130RTL D1SK3 L1 Introduction to yosys
Yosys is a synthesizer, a tool used for converting the RTL to netlist.Fig 5 shows the flow of yosys,applying design and .lib files to yosys we get netlist as output.read_verilog command is used to read the design, read_liberty command to read the .lib file and write_verilog command to write out the netlist file.Netlist is representation of the design in form of cells present in .lib.
![5](https://user-images.githubusercontent.com/62790565/183275983-e5d109b6-a27e-4dc2-ab8b-1d9cacadafb6.jpeg)
<br>Fig 5
<br>Output of simulating by applying netlist and testbench to iverilog and viewing generated vcd file on gtkwave toolshould be same as output of simulating by applying design and testbench to iverilog and viewing generated vcd file on gtkwave provided testbench applied in both the cases should is same, then the sysnthesis is said to be verified.
![6](https://user-images.githubusercontent.com/62790565/183276366-111784a5-b222-4721-90f6-b44a21aa0112.jpeg)
Fig 6
#### 1.3.2 SKY130RTL D1SK3 L2 Introduction to logic synthesis part1
RTL design is a behavioral representation of the required specification .Synthesis is RTL to Gate level translation. the design is converted into gates and the connections are made between the gates. This gives out as a file called netlist.Fig 7 gives the illustration of synthesis
![7](https://user-images.githubusercontent.com/62790565/183277889-190764f8-0f55-462c-8226-6d74e1f8a031.jpeg)

<br>Fig 7
<br>.lib is a collection of logical modules.It includes basic logic gates like And, Or, Not, etc. Same gate has different flavours such has slow, medium, fast.

![8](https://user-images.githubusercontent.com/62790565/183277894-226874e3-d83e-43c2-9e27-39dff657d03b.jpeg)

<br>Fig 8
<br>Consider the above digital circuit, the minimum clock period is given by the equation :
```
Tclk > Tcq-a + Tcombi +Tsetup-b
```
Combinational delay in logic path determines the maximum speed of operation of digital logic circuit.So we need fast cells to make Tcombi small increases the speed of operation.The following equation gives the maximum hold time
```
Thold_b < Tcq_a +Tcombi
```
To ensure that there are n "HOLD" issues at DFF_B shown in Fig 8,  we need cells that work slowly. Hence we need cells that works fast to meet the required performance and we need cells that work slow to meet HOLD. This collection of different flavours of cells forms the .lib . Load in the Digital Logic circuit is capacitance. Faster the charging/ discharging of capacitance lesser the cell delay. To charge or discharge the capacitance fast, we need transistors capable of sourcing more current. Wide transistors offfers low delay but requires mre area and power. Narrow transistors requires less area and power but offers more delay. Hence faster cells comes with a penality of area and power.
### 1.4 SKY130RTL D1SK4 Labs using Yosys and SKY130PDK's
#### 1.4.1 SKY130RTL D1SK4 L1 Lab3 yosys 1 good mux Part1
Moving into VLSI to sky130RTLDesignAndSynthesisWorkshop to verilog_files and then invoking yosys
```
$ cd VLSI
$ cd sky130RTLDesignAndSynthesisWorkshop
$ cd verilog_files
$ yosys
yosys >
```
Reading library files and design of multiplexer and synthesizing it and displaying gates
```
> read_liberty -lib /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
> read_verilog good_mux.v
> synth -top good_mux
> abc -liberty /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
> show
```

![Screenshot from 2022-08-07 12-13-20](https://user-images.githubusercontent.com/62790565/183279565-365fd63f-2081-43d2-952d-8ef6bf9b1ce3.png)

Generating netlist and displaying it
```
> write_verilog -noattr good_mux_netlist.v
> !gvim good_mux_netlist.v
```
Fig9 shows the netlist
## 2. Day 2-Timing libs, hierarchial vs flat synthesis and efficient flop coding styles
### 2.1 SKY130RTL D2SK1 -Introduction to timing.libs
#### 2.1.1 SKY130RTL D2SK1 L1 Lab4 Introduction to dot lib part1
This lab guides us through the .lib files where we have all the gates coded in. According to the below parameters the libraries will be characterized to model the variations.sky130_fd_sc_hd__tt_025C_1v80 named library is 130 nm library typical process at 25 degree celsius and at 1v.
![10](https://user-images.githubusercontent.com/62790565/183284976-2063f72b-86e6-4560-ae0e-17af548b3fbd.JPG)
<br> Fig 10
<br> With in the lib file, the gates are delared as follows to meet the variations due to process, temperatures and voltages.
With in the lib file, the gates are declared as follows to meet the variations due to process, temperatures and voltages.
![Screenshot from 2022-08-07 15-32-47](https://user-images.githubusercontent.com/62790565/183285736-6d66015a-5f6d-484c-8767-52429e2aacdf.png)
<br> Fig 11
<br> For the above example, for all the 2 combinations i.e 2^2 (2 is no.of  input variables), the delay, power and all the related parameters for each gate are mentioned.
<br> This image displays the power consumtion comparision.
![166107259-6fa398a4-2099-4da3-9b93-818c2c3f2404](https://user-images.githubusercontent.com/62790565/183285918-594e9856-9207-4220-8e1f-6a1e6a933152.JPG)
<br> Fig 12
<br> Below image is the delay order for the different flavor of gates.
![166187423-d21465e1-abc3-4ad0-a534-60f8e706ab6f](https://user-images.githubusercontent.com/62790565/183285933-a9fb50a8-493d-4c6a-b198-3db670c4ff35.JPG)
<br> Fig 13
### 2.2 SKY130RTL D2SK2 - Hierarchial vs Flat Synthesis
#### 2.2.1 SKY130RTL D2SK2 L1 Lab5 hierarchial vs flat synthesis part1
Design having multiple modules in it are analyzed here.Consider the multiple_modules.v design consisting two submodules. code of this design is :
```
module sub_module2 (input a, input b, output y);
	assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
	assign y = a&b;
endmodule


module multiple_modules (input a, input b, input c , output y);
	wire net1;
	sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
	sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule
```
To invoke yosys and synthesize use the following commands:
```
$ yosys
> read_liberty -lib /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
> read_verilog multiple_modules.v
> synth -top multiple_modules
> abc -liberty /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
To display gatelevel design use the following command:
```
> show multiple_modules
```
This displays hierarchial design as shown in Fig
![Screenshot from 2022-08-07 15-58-25](https://user-images.githubusercontent.com/62790565/183287346-cce344ba-1fd5-41c7-b54d-5634eac064e6.png)
<br> Fig 14
<br> To generate netlist and display is use the following commands
```
> write_verilog -noattr multiple_modules_hier_netlist.v
> !gvim good_mux_netlist.v
```
<br> The synthesizer considers the module hierarcy and does the mapping accordting to instantiation. Here is the hierarchical netlist code for the multiple_modules:
```
module multiple_modules(a, b, c, y);
	  input a;
	 input b;
	 input c;
	  wire net1;
	 output y;
  sub_module1 u1 (.a(a),.b(b),.y(net1) );
  sub_module2 u2 (.a(net1),.b(c),.y(y));
endmodule

module sub_module1(a, b, y);
 wire _0_;
 wire _1_;
 wire _2_;
 input a;
 input b;
 output y;
 sky130_fd_sc_hd__and2_0 _3_ (.A(_1_),.B(_0_),.X(_2_));
 assign _1_ = b;
 assign _0_ = a;
 assign y = _2_;
endmodule

module sub_module2(a, b, y);
wire _0_;
 wire _1_;
 wire _2_;
input a;
input b;
 output y;
 sky130_fd_sc_hd__lpflow_inputiso1p_1 _3_ (.A(_1_),.SLEEP(_0_),.X(_2_) );
 assign _1_ = b;
 assign _0_ = a;
 assign y = _2_;
endmodule
```
#### 2.2.2 SKY130RTL D2SK2 L2 Lab5 hierarchial vs flat synthesis part2
The following commands are used to flatten the hierarchy and display gate level circuits:
```
> flatten
> show
```
![Screenshot from 2022-08-07 16-12-44](https://user-images.githubusercontent.com/62790565/183287459-a3cd6edd-60cf-4802-ae21-b959de02f371.png)
<br> Fig 15
<br> To generate netlist and display is use the following commands
```
> write_verilog -noattr multiple_modules_flatten_netlist.v
> !gvim good_mux_netlist.v
```
<br> In flattened netlist, the hierarcies are flattend out and there is single module i.e, gates are instantiated directly instead of sub_modules. Here is the flattened netlist code for the multiple_modules:
```
module multiple_modules(a, b, c, y);
	 wire _0_;
	 wire _1_;
	 wire _2_;
	 wire _3_;
	 wire _4_;
	 wire _5_;
	 input a;
	 input b;
	 input c;
	 wire net1;
	 wire \u1.a ;
	 wire \u1.b ;
	 wire \u1.y ;
	 wire \u2.a ;
	 wire \u2.b ;
	 wire \u2.y ;
	output y;
	 sky130_fd_sc_hd__and2_0 _6_ (
	  .A(_1_),
	 .B(_0_),
	 .X(_2_)
	);
	 sky130_fd_sc_hd__lpflow_inputiso1p_1 _7_ (
	  .A(_4_),
	  .SLEEP(_3_),
	  .X(_5_)
	 );
	 assign _4_ = \u2.b ;
	 assign _3_ = \u2.a ;
	 assign \u2.y  = _5_;
	 assign \u2.a  = net1;
	 assign \u2.b  = c;
	 assign y = \u2.y ;
	 assign _1_ = \u1.b ;
	 assign _0_ = \u1.a ;
	 assign \u1.y  = _2_;
	 assign \u1.a  = a;
	 assign \u1.b  = b;
	 assign net1 = \u1.y ;
	endmodule
```
Module level synthesis
The following commands are used to synthesize and to show gatelevel circuit of submodule1 of multiple_modules.v design
```
> read_liberty -lib /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
> read_verilog multiple_modules.v
> synth -top submodule1
> abc -liberty /home/anusha/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
> show
```
![Screenshot from 2022-08-07 16-52-44](https://user-images.githubusercontent.com/62790565/183288320-e6233a10-c27f-407a-adf9-5e9f635a3542.png)
<br> Fig 16
<br> Module level synthesis is significant when there is multiple instantiation of same module.
### 2.3 SKY130RTL D2SK3 - Various Flop Coding Styles and optimization
#### 2.3.1 SKY130RTL D2SK3 L1 Why Flops and Flop coding styles part1






